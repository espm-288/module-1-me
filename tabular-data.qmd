---
title: "Module 1: Tabular Data"
subtitle: "Working with larger-than-RAM data using duckdbfs"
author: "ESPM 288"
format: 
  html:
    embed-resources: true
    code-fold: true
---

## Introduction

In this module, we will explore high-performance workflows for tabular data. We will use `duckdbfs` to work with datasets that are larger than available RAM by leveraging DuckDB's streaming and remote file access capabilities.

## Case Study: Global Supply Chains

We will be working with [EXIOBASE 3.8.1](https://source.coop/youssef-harby/exiobase-3), a global Multi-Regional Input-Output (MRIO) database. This dataset tracks economic transactions between sectors and regions, along with their environmental impacts (emissions, resource use, etc.).

**Data description:**
- **Coverage**: 44 countries + 5 rest-of-world regions.
- **Timeframe**: 1995â€“2022.
- **Content**: Economic transactions (Z matrix), final demand (Y matrix), and environmental stressors (F matrix).
- **Format**: Cloud-optimized Parquet, partitioned by year and matrix type.

## Setup

```{r}
#| output: false

library(duckdbfs)
library(dplyr)

```

## Exercise 1: connecting to remote data

We can open the entire dataset without downloading it using `open_dataset()`. The data is hosted on Source Cooperative. The `**` pattern allows recursive scanning of the partitioned parquet files.

```{r}
#| output: false
# Remote S3 path to EXIOBASE 3 (Source Cooperative)
duckdbfs::duckdb_secrets(
    key = "",
    secret = "",
    endpoint = "s3.amazonaws.com",
    region = "us-west-2"
)

s3_url <- "s3://us-west-2.opendata.source.coop/youssef-harby/exiobase-3/4588235/parquet/**"

# Open the dataset lazily
exio <- open_dataset(s3_url)
```

```{r}
# View the schema (column names and types) without reading data
glimpse(exio)
```



## Exercise 3: CO2 Production Data

Let's read in CO2 production data from the F_satellite matrix, which contains raw environmental stressors in physical units.

```{r}
#| output: false
library(stringr)

# Read CO2 emissions data for all years
co2_data <- exio |>
    filter(matrix == "F_satellite", str_detect(stressor, "CO2")) |>
    collect()
```

```{r}
# View the structure
co2_data |> head(10) |> knitr::kable()
```

```{r}
# Check unique CO2 stressors
co2_data |>
    distinct(stressor, unit) |>
    arrange(stressor) |>
    knitr::kable()
```

The dataset contains **973,538 rows** with 6 different types of CO2 emissions:

1. **CO2 - agriculture - peat decay - air** (from peatland degradation)
2. **CO2 - combustion - air** (from burning fossil fuels)
3. **CO2 - non combustion - Cement production - air** (from chemical process)
4. **CO2 - non combustion - Lime production - air** (from chemical process)
5. **CO2 - waste - biogenic - air** (from organic waste decomposition)
6. **CO2 - waste - fossil - air** (from fossil-based waste)

All values are measured in **kilograms (kg)**.

## Exercise 4: Time Series of Top CO2 Emitters

Let's identify the top 5 CO2 emitting countries and visualize their emissions over time.

```{r}
#| output: false
library(ggplot2)
library(scales)

# First, identify the top 5 emitting countries (total across all years)
top5_countries <- co2_data |>
    group_by(region) |>
    summarise(total_co2 = sum(value, na.rm = TRUE)) |>
    arrange(desc(total_co2)) |>
    slice_head(n = 5) |>
    pull(region)

# Aggregate CO2 by year and country for top 5 emitters
co2_timeseries <- co2_data |>
    filter(region %in% top5_countries) |>
    group_by(year, region) |>
    summarise(total_co2_kg = sum(value, na.rm = TRUE), .groups = "drop") |>
    mutate(total_co2_mt = total_co2_kg / 1e9) # Convert kg to million tonnes
```

```{r}
# Create line plot
ggplot(co2_timeseries, aes(x = year, y = total_co2_mt, color = region)) +
    geom_line(linewidth = 1.2) +
    geom_point(size = 2) +
    scale_y_continuous(labels = comma) +
    labs(
        title = "CO2 Emissions Over Time: Top 5 Countries (1995-2022)",
        x = "Year",
        y = "Total CO2 Emissions (Million Tonnes)",
        color = "Country"
    ) +
    theme_minimal(base_size = 14) +
    theme(
        plot.title = element_text(face = "bold", hjust = 0.5),
        legend.position = "right",
        panel.grid.minor = element_blank()
    )
```

